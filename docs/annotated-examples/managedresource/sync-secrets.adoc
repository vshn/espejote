# Sync secrets between Kubernetes namespaces

This example demonstrates copying a `Secret` resource from a source namespace to multiple target namespaces.
The target namespaces are selected using a label selector.
Whenever the source `Secret` or any of the target namespaces, or managed secrets change, the `ManagedResource` reconciles and ensures that the `Secret` exists in all target namespaces with the same data values as the source `Secret`.

The secret can be of any type, here we use an `Opaque` secret as an example.

The password value can be created using this command: `echo -n supersecret | base64 -w0`

## Manifest

[source,yaml]
----
---
apiVersion: v1 <1>
kind: Secret
metadata:
  name: source-secret
  namespace: secret-sync-namespace
data:
  password: c3VwZXJzZWNyZXQ= # "supersecret"
type: Opaque
---
apiVersion: espejote.io/v1alpha1
kind: ManagedResource
metadata:
  name: sync-secret
  namespace: secret-sync-namespace
spec:
  context:
    - name: source_secret <2>
      resource:
        apiVersion: v1
        kind: Secret
        name: source-secret
        namespace: secret-sync-namespace
    - name: target_namespaces <3>
      resource:
        apiVersion: v1
        kind: Namespace
        labelSelector:
          matchLabels:
            example.com/sync-secret: "true"
  triggers:
    - name: namespace <4>
      watchContextResource:
        name: target_namespaces
    - name: source_secret
      watchContextResource:
        name: source_secret
    - name: managed_secret <5>
      watchResource:
        apiVersion: v1
        kind: Secret
        namespace: ""
        labelSelector:
          matchLabels:
            espejote.io/managed-by: secret-sync-namespace.sync-secret
  serviceAccountRef:
    name: sync-secret-manager
  template: |
    local esp = import 'espejote.libsonnet';

    local inDelete(obj) = std.get(obj.metadata, 'deletionTimestamp', '') != '';

    local wants_secret(ns) =
      local nsLabels = std.get(ns.metadata, 'labels', {});
      !inDelete(ns) && std.get(nsLabels, 'example.com/sync-secret', 'false') == 'true';

    assert std.length(esp.context().source_secret) == 1 : "Expected to have exactly one source secret"; <6>
    local secret = esp.context().source_secret[0];

    local copy_to(nsname) = {
      apiVersion: 'v1',
      kind: 'Secret',
      metadata: {
        name: secret.metadata.name,
        namespace: nsname,
        labels: {
          'espejote.io/managed-by': 'secret-sync-namespace.sync-secret',
        },
      },
      data: secret.data,
      type: secret.type,
    };

    if esp.triggerName() == 'namespace' then ( <7>
      local ns = esp.triggerData().resource; <8>
      if ns != null && wants_secret(ns) then copy_to(ns.metadata.name)
    ) else if esp.triggerName() == 'managed_secret' then ( <9>
      local tdata = esp.triggerData();
      // by using the resource event when a managed secret is reconciled we
      // don't have to care about whether we got triggered due to a
      // modification or deletion of the secret.
      local secretNs = std.filter(
        function(ns) ns.metadata.name == tdata.resourceEvent.namespace, <10>
        esp.context().target_namespaces
      );
      if std.length(secretNs) == 1 && wants_secret(secretNs[0]) then
        copy_to(tdata.resourceEvent.namespace)
    ) else [ <11>
      copy_to(ns.metadata.name)
      for ns in esp.context().target_namespaces
      if wants_secret(ns)
    ]
----
<1> Example of a source `Secret`. It might already exist.
<2> Context resource pointing to the source `Secret`.
<3> Context resource pointing to the target namespaces using a label selector.
Only namespaces with the label `example.com/sync-secret=true` will receive the secret.
<4> Trigger that reconciles the `ManagedResource` when a target namespace is created, modified or deleted.
Uses the same cache as the `target_namespaces` context resource.
<5> Trigger that reconciles the `ManagedResource` when a managed secret is created, modified or deleted.
Filtered by the label `espejote.io/managed-by=secret-sync-namespace.sync-secret` injected by the template itself.
<6> Assertion to ensure the source secret exists in the context.
Context resources always return an array of resources, even if only a single resource is expected.
If no referenced resource exists, the array is empty.
The assertion causes the reconciliation to fail in that case, which adds an event to the `ManagedResource` and to the triggering resource.
Jsonnet does not allow early exits but the check could guard the final `if` expression instead as jsonnet is lazy-evaluated.
+
[source]
----
if std.length(esp.context().source_secret) == 1 then
  if esp.triggerName() == 'namespace' then
    ...
----
<7> When triggered by a namespace event, reconcile only that namespace.
<8> The full triggering resource is available in `esp.triggerData().resource`.
Can be `null` if the resource was deleted.
<9> When triggered by a managed secret event, reconcile only the namespace of that secret.
<10> `resourceEvent` contains the raw event data, including the namespace of the secret.
This data always exists, even if the resource was deleted.
<11> Default reconciliation: create/update the secret in all target namespaces.
Also triggers on source secret change through the `source_secret` trigger.

### RBAC [[rbac]]

[source,yaml]
----
---
apiVersion: v1 <1>
kind: ServiceAccount
metadata:
  name: sync-secret-manager
  namespace: secret-sync-namespace
---
apiVersion: rbac.authorization.k8s.io/v1 <2>
kind: ClusterRole
metadata:
  name: secret-sync-namespace:sync-secret-manager
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["*"]
  - apiGroups: [""]
    resources: ["namespaces"]
    verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: secret-sync-namespace:sync-secret-manager
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: secret-sync-namespace:sync-secret-manager
subjects:
  - kind: ServiceAccount
    name: sync-secret-manager
    namespace: secret-sync-namespace
----
<1> The `ServiceAccount` is used to authenticate to the API server.
<2> The `ManagedResource` needs to be able to watch `Namespace` resources and to read and update `Secret` resources.
